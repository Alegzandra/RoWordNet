import networkx as nx
from synset import Synset
import os
import lxml.etree as et
from collections import defaultdict
import pickle
from errors.verifications import *
from queue import Queue


class WordNet:
    def __init__(self, filename=None, empty=False, xml=True):
        """
            Initialize a wordnet object.
            
            Args:
                filename (str, optional): File to load from. If filename==None, load from internal resources. If filename ends
                                          with ".xml" we load from xml, else load in binary mode
                empty (bool, optional): Set to true only if you want an empty wordnet object (i.e. for manual wordnet editing
                                        purposes, etc.)
        """

        self._clean()
        if empty:
            return

        if filename is None:
            # load from internal resources as binary
            self._load_from_xml("resources/RoWn.xml") # trecem pe binar dupa salvare
            return

        if xml is True:
            # load from xml 
            self._load_from_xml(filename)
        elif xml is False:
            # load from binary file
            self._load_from_binary(filename)
        else:
            raise TypeError("Argument 'xml' has incorrect type (expected str, got {})".format(type(xml).__name__))

    def _clean(self):
        self._graph = nx.DiGraph()
        self._synsets = {}  # dictionary of synsets indexed by id(str)
        self._literal2synset = defaultdict(list)  # dictionary containing lists of synsets indexed by literal
        self._relations_type = set()  #set of relation types

    @property
    def relations_type(self):
        """
            Gets the set of possible relations between edges

            Returns:
                A list containing all the possible relations between edges.
        """

        return self._relations_type

    def save(self, filename, xml=True):
        """
            Saves a wordnet object.
            
            Args:
                filename (str): File to save to.
                xml (bool, optional): If True, it will save in xml format, else it will save in binary format.
        """

        if xml is True:
            self._save_to_xml(filename)
        elif xml is False:
            self._save_to_binary(filename)
        else:
            raise TypeError("Argument 'xml' has incorrect type (expected str, got {})".format(type(xml).__name__))

    def load(self, filename, xml=True):
        """
            Loads a wordnet object.

            Args:
                filename (str): File to load_from.
                xml (bool, optional): If True, it will load from xml format, else it will load from binary format.
        """

        if xml is True:
            self._load_from_xml(filename)
        elif xml is False:
            self._load_from_binary(filename)
        else:
            raise TypeError("Argument 'xml' has incorrect type (expected str, got {})".format(type(xml).__name__))

    def _load_from_xml(self, filename):
        if not os.path.isfile(filename):
            raise FileNotFoundError('No such file: {}'.format(filename))

        root = et.parse(filename).getroot()

        for child in root:
            synset = Synset('0')

            for element in child:
                if element.tag == 'ID':
                    verify_synid_not_in_wordnet(element.text, self._synsets.keys())
                    synset.id = element.text

                if element.tag == 'POS':
                    dic_chr2pos = {'n': Synset.Type.NOUN, 'v': Synset.Type.VERB, 'r': Synset.Type.ADVERB, 'a': Synset.Type.ADJECTIVE}
                    pos = dic_chr2pos[element.text]
                    synset.pos = pos

                if element.tag == 'SYNONYM':
                    synset.literals = {literal.text: literal[0].text for literal in element}
                    for literal in element:
                        self._literal2synset[literal.text].append(synset.id)

                if element.tag == 'STAMP':
                    synset.stamp = element.text

                if element.tag == 'ILR':
                    self._relations_type.add(element[0].text)

                    self._graph.add_edge(synset.id, element.text, label=element[0].text)

                if element.tag == 'DEF':
                    synset.definition = element.text

                if element.tag == 'DOMAIN':
                    synset.domain = element.text

                if element.tag == 'SUMO':
                    synset.sumo = element.text
                    dic_chr2sumotype = {'+': Synset.SumoType.HYPERNYM, '=': Synset.SumoType.EQUIVALENT, '@': Synset.SumoType.INSTANCE,
                                        '[': Synset.SumoType.BRACKET, ':': Synset.SumoType.POINTS}
                    sumotype = dic_chr2sumotype[element[0].text]
                    synset.sumotype = sumotype

                if element.tag == 'SENTIWN':
                    synset.sentiwn = [float(subelement.text) for subelement in element]

            self._synsets[synset.id] = synset

    # idk how to do that????
    def _load_from_binary(self, filename):
        pass

    def _save_to_xml(self, filename):
        root = et.Element("ROWN")

        for synset in self._synsets.values():
            syn = et.SubElement(root, "SYNSET")

            et.SubElement(syn, "ID").text = synset.id

            et.SubElement(syn, "POS").text = str(synset.pos)

            synonym = et.SubElement(syn, "SYNONYM")
            for literal in synset.literals:
                lit = et.SubElement(synonym, "LITERAL")
                lit.text = literal
                et.SubElement(lit, "TYPE").text = "type"

            if synset.stamp is not None:
                et.SubElement(syn, "STAMP").text = synset.stamp

            if synset.id in self._graph.adj.keys():
                for target_node_id, edge_data in self._graph[synset.id].items():
                    ilr = et.SubElement(syn, "ILR")
                    ilr.text = target_node_id
                    et.SubElement(ilr, "TYPE").text = edge_data['label']
            if synset.definition is not None:
                et.SubElement(syn, "DEF").text = synset.definition

            if synset.domain is not None:
                et.SubElement(syn, "DOMAIN").text = synset.domain

            if synset.sumo is not None:
                sumo = et.SubElement(syn, "SUMO")
                sumo.text = synset.sumo
                et.SubElement(sumo, "TYPE").text = str(synset.sumotype)

            if synset.sentiwn is not None:
                sentiwn = et.SubElement(syn, "SENTIWN")
                et.SubElement(sentiwn, "P").text = str(synset.sentiwn[0])
                et.SubElement(sentiwn, "N").text = str(synset.sentiwn[1])
                et.SubElement(sentiwn, "O").text = str(synset.sentiwn[2])

        tree = et.ElementTree(root)
        tree.write(filename, encoding="utf-8", pretty_print=True)

    def _save_to_binary(self, filename):
        pickle.dump(self, open(filename, "wb"))

    def synsets(self, word=None, pos=None, relation=None):
        """
            Gets a list of synsets that contain a particular word, filtered (if pos is given) by its part of speech
        
            Args:
                word (str, optional): The word searched for. If word == None, return all synsets (filtered by pos, if given)
                pos (Synset.Type, optional): Filter synsets that have only this POS. Can be either NOUN, VERB, ADJECTIVE or ADVERB
                relation (str, optional): Specifies the relation between the word and the searched synsets
            
            Returns:
                list: All synsets that contain the word. If a relation is specified returns all the synsets with the specific
                      relation from all synsets containing the word
        """

        if word is None:
            synsets = list(self._synsets.values())
        elif word not in self._literal2synset:
            return []
        else:
            verify_type(word, 'word', str)

            synsets_id = self._literal2synset[word]
            synsets = [self._synsets[synset_id] for synset_id in synsets_id]

        if pos is not None:
            verify_valid_pos(pos, Synset.Type)

            synsets = [synset for synset in synsets if synset.pos == pos]

        if relation is not None:
            if word is None:
                raise TypeError("Argument 'relation' must be NoneType if argument 'word' is NoneType, got {})".format(type(relation).__name__))

            verify_type(relation, 'relation', str)
            verify_valid_relation(relation, self._relations_type)

            synsets_id = []

            for synset in synsets:
                adj_synsets = self._graph[synset.id] if synset.id in self._graph.adj.keys() else {}
                synsets_id.extend(synset for synset, data in adj_synsets.items() if data['label'] == relation)

                synsets = [self._synsets[synset_id] for synset_id in synsets_id]

        return synsets

    def synset(self, synset_id):
        """
            Gets a synset given its id
        
            Args:
                synset_id (str): The id of the synset
            
            Returns:
                synset: The synset with the given id or None if the id isn't found
        """

        verify_type(synset_id, 'synset_id', str)
        verify_synid_in_wordnet(synset_id, self._synsets.keys())

        return self._synsets[synset_id]

    def generate_id(self, prefix='ENG30-', suffix='-n'):
        """
            Generate the first available id that starts with the given prefix and end with the given suffix.

            Args:
                prefix(str): the given prefix
                suffix(str): the given sufix

            Returns:
                The first available id that starts with the given prefix and end with the given suffix.

        """

        verify_type(prefix, 'prefix', str)
        verify_type(suffix, 'suffix', str)

        matched = False
        maximum = 0

        for synset_id in self._synsets:
            if not synset_id.startswith(prefix):
                continue
            if not synset_id.endswith(suffix):
                continue

            matched = True

            synset_id = synset_id.replace(prefix, "")
            synset_id = synset_id.replace(suffix, "")

            if int(synset_id) > maximum:
                maximum = int(synset_id)

        if matched:
            return "{}{:08d}{}".format(prefix, maximum+1, suffix)
        else:
            return "{}{:08d}{}".format(prefix, 1, suffix)

    def add_synset(self, synset, to_relations=None, from_relations=None):
        """
            Adds a synset to wordnet.

            Args:
                synset(Synset): the synset object to be added.
                to_relations(dict, optionaly): dictionary containing the id and relation type of synsets it points to.
                from_relations(dict, optionaly): dictionary containing the id and relation type of synsets that are pointing to this synset.
        """
        verify_type(synset, 'synset', Synset)
        verify_synid_not_in_wordnet(synset.id, self._synsets.keys())

        self._graph.add_node(synset.id)
        self._synsets[synset.id] = synset
        for literal in synset.literals:
            self._literal2synset[literal].append(synset.id)

        if to_relations is not None:
            for synset_id, relation in to_relations.items():
                verify_type(synset_id, 'dict_synsetid - to relations', str)
                verify_synid_in_wordnet(synset_id, self._synsets.keys())
                verify_type(relation, 'dict_relation - to relations', str)
                verify_valid_relation(relation, self._relations_type)

                self._graph.add_edge(synset.id, synset_id, label=relation)

        if from_relations is not None:
            for synset_id, relation in from_relations.items():
                verify_type(synset_id, 'dict_synsetid - from relations', str)
                verify_synid_in_wordnet(synset_id, self._synsets.keys())
                verify_type(relation, 'dict_relation - from relations', str)
                verify_valid_relation(relation, self._relations_type)

                self._graph.add_edge(synset_id, synset.id, label=relation)

    def add_literal(self, word, sense, synset_id):
        """
            Adds a literal to a synset given its id.

            Args:
                synset_id(str): id of the synset.
                word(str): name of the literal.
                sense(str): sense of the literal.
        """
        verify_type(synset_id, 'synset', str)
        verify_synid_in_wordnet(synset_id, self._synsets.keys())
        verify_type(word, 'word', str)
        verify_type(sense, 'sense', str)

        synset = self._synsets[synset_id]
        synset.add_literal(word, sense)
        self._literal2synset[word].append(synset_id)

    def remove_literal(self, word, synset_id=None):
        """
            Removes a literal from synset given its id. If no id is given then it will remove this literal from all synsets

            Args:
                word(str): name of the literal.
                synset_id(str, optional): id of the synset.
        """

        verify_type(word, 'word', str)

        if synset_id is not None:
            verify_type(synset_id, 'synset', str)
            verify_synid_in_wordnet(synset_id, self._synsets.keys())

            synset = self._synsets[synset_id]
            synset.remove_literal(word)
            self._literal2synset[word].remove(synset_id)
        else:
            self._literal2synset.pop(word)

            synsets_id = self._literal2synset[word]

            for synset_id in synsets_id:
                synset = self._synsets[synset_id]
                synset.remove_literal(word)

    def add_relation(self, synset_id1, synset_id2, relation):
        """
            Adds a new relation in wordnet. Relation will always be from synset_id1 to synset_id2.

            Args:
                synset_id1(str): Id of the first synset.
                synset_id2(str): Id of the second synset.
                relation(str): Relation type between the synsets.
        """

        verify_type(synset_id1, 'synset_id1', str)
        verify_synid_in_wordnet(synset_id1, self._synsets.keys())
        verify_type(synset_id2, 'synset_id2', str)
        verify_synid_in_wordnet(synset_id2, self._synsets.keys())
        verify_type(relation, 'relation', str)
        verify_valid_relation(relation, self._relations_type)
        verify_relation_not_in_wordnet(synset_id1, synset_id2, self._graph)

        self._graph.add_edge(synset_id1, synset_id2, label=relation)

    def remove_relation(self, synset_id1, synset_id2):
        """
            Removes relation between two synsets. Relation is always from first synset to second synset.

            Args:
                synset_id1(str): id of the first synset.
                synset_id2(str): id of the second synset.
        """

        verify_type(synset_id1, 'synset_id1', str)
        verify_synid_in_wordnet(synset_id1, self._synsets.keys())
        verify_type(synset_id2, 'synset_id2', str)
        verify_synid_in_wordnet(synset_id2, self._synsets.keys())
        verify_relation_in_wordnet(synset_id1, synset_id2, self._graph)

        self._graph.remove_edge(synset_id1, synset_id2)

    # este ok sa las label-ul in lista? returneaza ceva de genul: { 'id_syn': { 'label': 'hypernym'}}
    def relations(self, to_synset_id=None, from_synset_id=None):
        """
            Gets a dictionary containing the relations in the wordnet.

            Args:
                to_synset_id(str, optional): id of synset to get relations from.
                from_synset_id(str, optional): id of synset to get relations to.

            Returns:
                A list containing the relations in the wordnet.
        """
        if to_synset_id is None and from_synset_id is None:
            return self._graph.edges(data=True)

        if from_synset_id is not None and to_synset_id is not None:
            raise WordNetError("Arguments 'to_synset_id' and 'from_synset_id' can't be both different from None")

        if from_synset_id is not None:
            verify_type(from_synset_id, 'from_synset_id', str)
            verify_synid_in_wordnet(from_synset_id, self._synsets.keys())

            return self._graph[from_synset_id]

        if to_synset_id is not None:
            verify_type(to_synset_id, 'to_synset_id', str)
            verify_synid_in_wordnet(to_synset_id, self._synsets.keys())

            relations = {}

            for (synset_id1, synset_id2, data) in self._graph.edges(data=True):
                if synset_id2 == to_synset_id:
                    relations[synset_id1] = data

            return relations

    def hypernyms_to_root(self, synset_id):
        """
            Gets a list containing the path from the given synset to the root in hypermyn tree.

            Args:
                synset_id(str): id of synset

            Returns:
                A list containing synset ids.
        """
        verify_type(synset_id, 'synset_id', str)
        verify_synid_in_wordnet(synset_id, self._synsets.keys())

        has_hypernym = True
        hypernyms_list = []

        while has_hypernym:
            adj_synsets = self._graph[synset_id]
            has_hypernym = False

            for adj_synset_id, adj_synset_data in adj_synsets.items():
                if adj_synset_data['label'] == 'hypernym':
                    has_hypernym = True
                    hypernyms_list.append(adj_synset_id)
                    synset_id = adj_synset_id

        return hypernyms_list

    # comment neimplementat
    def bfwalk(self, synset_id):
        init_list = [synset_id]
        final_list = []

        while not len(init_list) == 0:
            for synid in init_list:
                print(synid)
                final_list.extend(self._graph[synid])

            init_list = final_list
            yield init_list

    def shortest_path(self, synset_id1, synset_id2, relations=None):
        """
            Gets the shortest path from synset_id1 to synset_id2 through all relations.

            Args:
                synset_id1(str): id of the first synset.
                synset_id2(str): id of the second synset.
                relations(str): type of relations allowed in path.

            Returns:
                The shortest path from the first synset to the second synset.
        """
        verify_type(synset_id1, 'synset_id1', str)
        verify_synid_in_wordnet(synset_id1, self._synsets.keys())
        verify_type(synset_id2, 'synset_id2', str)
        verify_synid_in_wordnet(synset_id2, self._synsets.keys())

        if relations is not None:
            verify_type(relations, 'relations', list)
            for relation in relations:
                verify_type(relation, 'list_relation - relations', str)
                verify_valid_relation(relation, self._relations_type)

        else:
            return nx.shortest_path(self._graph, synset_id1, synset_id2)

    def similarity(self, word1, word2):
        """
            Gets the similarity between two words.

            Args:
                word1(str): First word to be searched by:
                word2(str): Second word to be searched by:

            Returns:
                int: A positive integer representing the similarity between words. The lower, the more similar.
                -1: If either word has not been found in wordnet.
        """

        pass



